"use strict";(self.webpackChunkcurvine_doc=self.webpackChunkcurvine_doc||[]).push([[7263],{520:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"User-Manuals/K8S-CSI-Driver/Framework","title":"Curvine CSI Architecture","description":"curvine-csi is based on FUSE implementation, establishing connection with Curvine cluster through FUSE mount in csi-node.","source":"@site/docs/3-User-Manuals/5-K8S-CSI-Driver/04-Framework.md","sourceDirName":"3-User-Manuals/5-K8S-CSI-Driver","slug":"/User-Manuals/K8S-CSI-Driver/Framework","permalink":"/docs/User-Manuals/K8S-CSI-Driver/Framework","draft":false,"unlisted":false,"editUrl":"https://github.com/curvineio/curvine-doc/edit/main/docs/3-User-Manuals/5-K8S-CSI-Driver/04-Framework.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Using Dynamic PV in StatefulSet","permalink":"/docs/User-Manuals/K8S-CSI-Driver/StatefulSet"},"next":{"title":"Benchmark","permalink":"/docs/category/benchmark"}}');var t=s(4848),l=s(8453);const i={},o="Curvine CSI Architecture",c={},d=[{value:"Architecture",id:"architecture",level:2},{value:"Mount Modes",id:"mount-modes",level:2},{value:"Standalone Mode (Recommended)",id:"standalone-mode-recommended",level:3},{value:"Resource Configuration",id:"resource-configuration",level:4},{value:"Embedded Mode",id:"embedded-mode",level:3},{value:"FUSE Process Reuse and Lifecycle Management",id:"fuse-process-reuse-and-lifecycle-management",level:2},{value:"Overview",id:"overview",level:3},{value:"Core Concepts",id:"core-concepts",level:3},{value:"ClusterID Generation",id:"clusterid-generation",level:4},{value:"Reference Counting",id:"reference-counting",level:4},{value:"Lifecycle Management",id:"lifecycle-management",level:3},{value:"Creation Phase",id:"creation-phase",level:4},{value:"Running Phase",id:"running-phase",level:4},{value:"Cleanup Phase (Automatic)",id:"cleanup-phase-automatic",level:4},{value:"PV Watch Fallback Mechanism",id:"pv-watch-fallback-mechanism",level:3},{value:"State Persistence",id:"state-persistence",level:3},{value:"RBAC Requirements",id:"rbac-requirements",level:3},{value:"Best Practices",id:"best-practices",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"curvine-csi-architecture",children:"Curvine CSI Architecture"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"curvine-csi"})," is based on FUSE implementation, establishing connection with Curvine cluster through FUSE mount in csi-node."]}),"\n",(0,t.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsxs)(n.p,{children:["The diagram below shows the overall design architecture of curvine-csi. ",(0,t.jsx)(n.strong,{children:"If you only need to use CSI, you can skip this chapter"})," and refer to ",(0,t.jsx)(n.a,{href:"Setup",children:"K8S CSI Driver"})," directly."]}),"\n",(0,t.jsx)(n.p,{children:"Curvine-csi mainly consists of two components:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Component"}),(0,t.jsx)(n.th,{children:"Responsibility"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"CSI Node Service"}),(0,t.jsx)(n.td,{children:"Handle CSI gRPC calls, manage MountPod lifecycle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"MountPod Controller"}),(0,t.jsx)(n.td,{children:"Create/Delete/Monitor MountPod"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"mount-modes",children:"Mount Modes"}),"\n",(0,t.jsx)(n.p,{children:"Most CSI implementations manage mounts directly in csi-node by mounting remote storage to hosts and finally bind mounting to pod containers. Curvine-csi is based on FUSE. When the CSI component restarts, the FUSE process will be interrupted. To avoid FUSE interruption caused by CSI driver upgrades or restarts, curvine-csi supports two mount modes: standalone and embedded."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Standalone"}),": Decouple the FUSE process from the csi-node pod and run it in an independent Pod"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Embedded"}),": FUSE process runs in the csi-node plugin pod"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"standalone-mode-recommended",children:"Standalone Mode (Recommended)"}),"\n",(0,t.jsx)(n.p,{children:"Default mode. Install with Helm:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"helm install curvine-csi ./curvine-csi \\\n  --set mountMode=standalone\n"})}),"\n",(0,t.jsx)(n.h4,{id:"resource-configuration",children:"Resource Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Configure Standalone Pod resource limits via Helm values:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"helm install curvine-csi ./curvine-csi \\\n  --set node.mountMode=standalone \\\n  --set node.standalone.resources.requests.cpu=500m \\\n  --set node.standalone.resources.requests.memory=512Mi \\\n  --set node.standalone.resources.limits.cpu=2 \\\n  --set node.standalone.resources.limits.memory=2Gi\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or use a values file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'node:\n  mountMode: standalone\n  standalone:\n    image: ""  # Empty uses CSI image\n    resources:\n      requests:\n        cpu: "500m"\n        memory: "512Mi"\n      limits:\n        cpu: "2"\n        memory: "2Gi"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Default configuration:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"CPU: requests 500m, limits 2"}),"\n",(0,t.jsx)(n.li,{children:"Memory: requests 512Mi, limits 2Gi"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Architecture diagram:"}),"\n",(0,t.jsx)(n.mermaid,{value:'%%{init: {\'theme\': \'base\', \'themeVariables\': { \'background\': \'#ffffff\', \'primaryColor\': \'#4a9eff\', \'primaryTextColor\': \'#1a202c\', \'primaryBorderColor\': \'#3182ce\', \'lineColor\': \'#4a5568\', \'secondaryColor\': \'#805ad5\', \'tertiaryColor\': \'#38a169\', \'mainBkg\': \'#ffffff\', \'nodeBorder\': \'#4a5568\', \'clusterBkg\': \'#f8f9fa\', \'clusterBorder\': \'#dee2e6\', \'titleColor\': \'#1a202c\'}}}%%flowchart TB\n    subgraph K8sNode["\ud83d\udda5\ufe0f Kubernetes Node"]\n        subgraph CSIPod["CSI Node Pod"]\n            CSIDriver["CSI Driver<br/>gRPC Handler"]\n            MountPodCtrl["MountPod<br/>Controller"]\n        end\n        \n        subgraph MountPods["MountPod Layer"]\n            subgraph MP1["MountPod-1 (privileged)"]\n                FUSE1["curvine-fuse<br/>Process"]\n                MNT1["/mnt/curvine/<br/>cluster-A"]\n            end\n            \n            subgraph MP2["MountPod-2 (privileged)"]\n                FUSE2["curvine-fuse<br/>Process"]\n                MNT2["/mnt/curvine/<br/>cluster-B"]\n            end\n        end\n        \n        subgraph HostFS["Host Filesystem"]\n            PluginPath["/var/lib/kubelet/plugins/curvine/"]\n            ClusterA["cluster-A/fuse-mount/"]\n            ClusterB["cluster-B/fuse-mount/"]\n        end\n        \n        subgraph AppPods["Application Pods"]\n            App1["App Pod 1"]\n            App2["App Pod 2"]\n            VolPath1["/var/lib/kubelet/pods/xxx/<br/>volumes/.../mount"]\n            VolPath2["/var/lib/kubelet/pods/yyy/<br/>volumes/.../mount"]\n        end\n        \n        subgraph External["Curvine Cluster"]\n            CurvineClusterA[("Curvine<br/>Cluster A")]\n            CurvineClusterB[("Curvine<br/>Cluster B")]\n        end\n    end\n    \n    %% CSI Pod manages MountPods\n    CSIDriver --\x3e MountPodCtrl\n    MountPodCtrl --\x3e|"Create/Delete"| MP1\n    MountPodCtrl --\x3e|"Create/Delete"| MP2\n    \n    %% FUSE processes connect to clusters\n    FUSE1 -.->|"gRPC"| CurvineClusterA\n    FUSE2 -.->|"gRPC"| CurvineClusterB\n    \n    %% FUSE mounts to host paths\n    FUSE1 --\x3e MNT1\n    MNT1 --\x3e|"Bidirectional<br/>Mount Propagation"| ClusterA\n    \n    FUSE2 --\x3e MNT2\n    MNT2 --\x3e|"Bidirectional<br/>Mount Propagation"| ClusterB\n    \n    %% Host paths organization\n    PluginPath --\x3e ClusterA\n    PluginPath --\x3e ClusterB\n    \n    %% App pods bind mount\n    ClusterA --\x3e|"bind mount<br/>+ subpath"| VolPath1\n    ClusterB --\x3e|"bind mount<br/>+ subpath"| VolPath2\n    \n    VolPath1 --\x3e App1\n    VolPath2 --\x3e App2\n\n    %% Styles - colors adjusted for light background\n    classDef csiStyle fill:#4a9eff,stroke:#2b6cb0,color:#fff,stroke-width:2px\n    classDef mountPodStyle fill:#805ad5,stroke:#553c9a,color:#fff,stroke-width:2px\n    classDef fuseStyle fill:#ecc94b,stroke:#b7791f,color:#1a202c,stroke-width:2px\n    classDef hostStyle fill:#48bb78,stroke:#276749,color:#fff,stroke-width:2px\n    classDef appStyle fill:#ed8936,stroke:#c05621,color:#fff,stroke-width:2px\n    classDef storageStyle fill:#fc8181,stroke:#c53030,color:#1a202c,stroke-width:2px\n    classDef pathStyle fill:#cbd5e0,stroke:#718096,color:#1a202c,stroke-width:1px\n    \n    class CSIDriver,MountPodCtrl csiStyle\n    class MP1,MP2 mountPodStyle\n    class FUSE1,FUSE2 fuseStyle\n    class PluginPath,ClusterA,ClusterB hostStyle\n    class App1,App2 appStyle\n    class CurvineClusterA,CurvineClusterB storageStyle\n    class MNT1,MNT2,VolPath1,VolPath2 pathStyle'}),"\n",(0,t.jsx)(n.h3,{id:"embedded-mode",children:"Embedded Mode"}),"\n",(0,t.jsx)(n.p,{children:"Install with Helm:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"helm install curvine-csi ./curvine-csi \\\n  --set node.mountMode=embedded \\\n  --set node.resources.requests.memory=2Gi \\\n  --set node.resources.requests.cpu=1000m \\\n  --set node.resources.limits.memory=4Gi \\\n  --set node.resources.limits.cpu=2000m\n"})}),"\n",(0,t.jsx)(n.p,{children:"Architecture diagram:"}),"\n",(0,t.jsx)(n.mermaid,{value:"%%{init: {'theme': 'base', 'themeVariables': { 'background': '#ffffff', 'primaryColor': '#4a9eff', 'primaryTextColor': '#1a202c', 'primaryBorderColor': '#3182ce', 'lineColor': '#4a5568', 'secondaryColor': '#805ad5', 'tertiaryColor': '#38a169', 'mainBkg': '#ffffff', 'nodeBorder': '#4a5568', 'clusterBkg': '#f8f9fa', 'clusterBorder': '#dee2e6', 'titleColor': '#1a202c'}}}%%flowchart TB\n    subgraph K8sNode[\"\ud83d\udda5\ufe0f Kubernetes Node\"]\n        subgraph CSIPod[\"CSI Node Pod (privileged)\"]\n            CSIDriver[\"CSI Driver<br/>gRPC Handler\"]\n            FUSE1[\"curvine-fuse<br/>Process\"]\n            FUSE2[\"curvine-fuse<br/>Process\"]\n            MNT1[\"/mnt/curvine/<br/>cluster-A\"]\n            MNT2[\"/mnt/curvine/<br/>cluster-B\"]\n        end\n        \n        subgraph HostFS[\"Host Filesystem\"]\n            PluginPath[\"/var/lib/kubelet/plugins/curvine/\"]\n            ClusterA[\"cluster-A/fuse-mount/\"]\n            ClusterB[\"cluster-B/fuse-mount/\"]\n        end\n        \n        subgraph AppPods[\"Application Pods\"]\n            App1[\"App Pod 1\"]\n            App2[\"App Pod 2\"]\n            VolPath1[\"/var/lib/kubelet/pods/xxx/<br/>volumes/.../mount\"]\n            VolPath2[\"/var/lib/kubelet/pods/yyy/<br/>volumes/.../mount\"]\n        end\n        \n        subgraph External[\"Curvine Cluster\"]\n            CurvineClusterA[(\"Curvine<br/>Cluster A\")]\n            CurvineClusterB[(\"Curvine<br/>Cluster B\")]\n        end\n    end\n    \n    %% FUSE processes connect to clusters\n    FUSE1 -.->|\"gRPC\"| CurvineClusterA\n    FUSE2 -.->|\"gRPC\"| CurvineClusterB\n    \n    %% FUSE mounts to host paths\n    FUSE1 --\x3e MNT1\n    MNT1 --\x3e|\"Bidirectional<br/>Mount Propagation\"| ClusterA\n    \n    FUSE2 --\x3e MNT2\n    MNT2 --\x3e|\"Bidirectional<br/>Mount Propagation\"| ClusterB\n    \n    %% Host paths organization\n    PluginPath --\x3e ClusterA\n    PluginPath --\x3e ClusterB\n    \n    %% App pods bind mount\n    ClusterA --\x3e|\"bind mount<br/>+ subpath\"| VolPath1\n    ClusterB --\x3e|\"bind mount<br/>+ subpath\"| VolPath2\n    \n    VolPath1 --\x3e App1\n    VolPath2 --\x3e App2\n\n    %% Styles\n    classDef csiStyle fill:#4a9eff,stroke:#2b6cb0,color:#fff,stroke-width:2px\n    classDef fuseStyle fill:#ecc94b,stroke:#b7791f,color:#1a202c,stroke-width:2px\n    classDef hostStyle fill:#48bb78,stroke:#276749,color:#fff,stroke-width:2px\n    classDef appStyle fill:#ed8936,stroke:#c05621,color:#fff,stroke-width:2px\n    classDef storageStyle fill:#fc8181,stroke:#c53030,color:#1a202c,stroke-width:2px\n    classDef pathStyle fill:#cbd5e0,stroke:#718096,color:#1a202c,stroke-width:1px\n    \n    class CSIDriver,FUSE1,FUSE2 csiStyle\n    class PluginPath,ClusterA,ClusterB hostStyle\n    class App1,App2 appStyle\n    class CurvineClusterA,CurvineClusterB storageStyle\n    class MNT1,MNT2,VolPath1,VolPath2 pathStyle"}),"\n",(0,t.jsx)(n.h2,{id:"fuse-process-reuse-and-lifecycle-management",children:"FUSE Process Reuse and Lifecycle Management"}),"\n",(0,t.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Curvine CSI implements intelligent FUSE process reuse mechanism. Using ",(0,t.jsx)(n.strong,{children:"ClusterID"})," as a unique identifier, multiple PVs can share the same FUSE process (Standalone Pod). This design significantly improves resource utilization and system performance."]}),"\n",(0,t.jsx)(n.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(n.h4,{id:"clusterid-generation",children:"ClusterID Generation"}),"\n",(0,t.jsxs)(n.p,{children:["ClusterID is generated from the first 8 characters of the SHA256 hash of ",(0,t.jsx)(n.code,{children:"master-addrs"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Example: Generate ClusterID from master-addrs\nmasterAddrs := "10.0.0.1:8995,10.0.0.2:8995,10.0.0.3:8995"\nclusterID := SHA256(masterAddrs)[:8]  // e.g., 0893a5f6\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Features"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Same ",(0,t.jsx)(n.code,{children:"master-addrs"})," \u2192 Same ClusterID \u2192 Shared Standalone Pod"]}),"\n",(0,t.jsxs)(n.li,{children:["Different ",(0,t.jsx)(n.code,{children:"master-addrs"})," \u2192 Different ClusterID \u2192 Independent Standalone Pod"]}),"\n",(0,t.jsx)(n.li,{children:"Multi-cluster support: Same node can run multiple Standalone Pods for different Curvine clusters"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"reference-counting",children:"Reference Counting"}),"\n",(0,t.jsx)(n.p,{children:"Each Standalone Pod maintains a reference count:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RefCount++"}),": When a new PV uses this Standalone Pod"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RefCount--"}),": When a PV is deleted"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Delete Pod"}),": When RefCount reaches 0 (no references)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"lifecycle-management",children:"Lifecycle Management"}),"\n",(0,t.jsx)(n.h4,{id:"creation-phase",children:"Creation Phase"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"First PV requests \u2192 Create Standalone Pod (RefCount: 0 \u2192 1)"}),"\n",(0,t.jsx)(n.li,{children:"Subsequent PVs with same master-addrs \u2192 Reuse existing Pod (RefCount++)"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"running-phase",children:"Running Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Standalone Pod serves multiple PVs simultaneously"}),"\n",(0,t.jsx)(n.li,{children:"Shared FUSE mount point"}),"\n",(0,t.jsx)(n.li,{children:"Shared gRPC connection to Curvine cluster"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"cleanup-phase-automatic",children:"Cleanup Phase (Automatic)"}),"\n",(0,t.jsx)(n.p,{children:"When the last PV is deleted:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"RefCount: 1 \u2192 0"}),"\n",(0,t.jsx)(n.li,{children:"Trigger automatic cleanup"}),"\n",(0,t.jsxs)(n.li,{children:["Graceful shutdown (30s):","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"preStop hook: 5s (wait for I/O)"}),"\n",(0,t.jsx)(n.li,{children:"Unmount FUSE"}),"\n",(0,t.jsx)(n.li,{children:"Clean up resources"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Delete Standalone Pod"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"pv-watch-fallback-mechanism",children:"PV Watch Fallback Mechanism"}),"\n",(0,t.jsx)(n.p,{children:"To handle abnormal cases (e.g., PV deleted directly without Unstage call), CSI implements PV Watch mechanism:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Triple Protection"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Main Path"}),": Normal Unstage call (fastest, 0 latency)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PV Watch"}),": Monitor PV deletion events (second-level response)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Periodic GC"}),": Scan orphaned Pods (10-minute fallback)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"state-persistence",children:"State Persistence"}),"\n",(0,t.jsx)(n.p,{children:"Reference counts and volume lists are stored in ConfigMap, ensuring state survives node restarts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: curvine-standalone-state-<nodename>\ndata:\n  state.json: |\n    {\n      "mounts": {\n        "0893a5f6": {\n          "clusterID": "0893a5f6",\n          "podName": "curvine-standalone-0893a5f6-aefd8804",\n          "refCount": 3,\n          "volumes": ["vol-1", "vol-2", "vol-3"]\n        }\n      }\n    }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"rbac-requirements",children:"RBAC Requirements"}),"\n",(0,t.jsx)(n.p,{children:"Standalone mode requires the following permissions:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Resource"}),(0,t.jsx)(n.th,{children:"Permissions"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"pods"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"create"}),", ",(0,t.jsx)(n.code,{children:"delete"}),", ",(0,t.jsx)(n.code,{children:"get"}),", ",(0,t.jsx)(n.code,{children:"list"}),", ",(0,t.jsx)(n.code,{children:"watch"})]}),(0,t.jsx)(n.td,{children:"Manage Standalone Pods"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"configmaps"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"create"}),", ",(0,t.jsx)(n.code,{children:"delete"}),", ",(0,t.jsx)(n.code,{children:"get"}),", ",(0,t.jsx)(n.code,{children:"list"}),", ",(0,t.jsx)(n.code,{children:"update"}),", ",(0,t.jsx)(n.code,{children:"watch"})]}),(0,t.jsx)(n.td,{children:"State persistence"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"persistentvolumes"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"get"}),", ",(0,t.jsx)(n.code,{children:"list"}),", ",(0,t.jsx)(n.code,{children:"watch"})]}),(0,t.jsx)(n.td,{children:"PV Watch fallback cleanup"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"events"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"create"}),", ",(0,t.jsx)(n.code,{children:"patch"})]}),(0,t.jsx)(n.td,{children:"Event logging and debugging"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Standalone Mode"})," (default, recommended)"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Independent FUSE process, CSI upgrades don't affect business"}),"\n",(0,t.jsx)(n.li,{children:"Resource isolation, clear problem domain"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use consistent master-addrs for same cluster"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Ensure PV's ",(0,t.jsx)(n.code,{children:"master-addrs"})," format is consistent"]}),"\n",(0,t.jsx)(n.li,{children:"Maximize FUSE process reuse"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Monitor Standalone Pods"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# View all Standalone Pods\nkubectl get pods -n curvine-system -l app=curvine-standalone\n\n# View reference count state\nkubectl get configmap -n curvine-system -l app=curvine-standalone-state\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Check logs for lifecycle events"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-log",children:"# Creation\nI1222 10:00:00 Creating Standalone for cluster 0893a5f6\n\n# Reference addition\nI1222 10:01:00 Added volume ref, refCount=2\n\n# Automatic cleanup\nI1222 10:15:00 Removed volume ref, refCount=0\nI1222 10:15:00 No more refs, deleting Standalone\n"})}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var r=s(6540);const t={},l=r.createContext(t);function i(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);